{
  "language": "Solidity",
  "settings": {
    "optimizer": { "enabled": true, "runs": 200 },
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
        "": ["ast"]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.22;\n\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\nimport {ERC1967Proxy} from \"../ERC1967/ERC1967Proxy.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {ProxyAdmin} from \"./ProxyAdmin.sol\";\n\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\n}\n\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    address private immutable _admin;\n\n    error ProxyDeniedAdminAccess();\n\n    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _admin = address(new ProxyAdmin(initialOwner));\n        ERC1967Utils.changeAdmin(_proxyAdmin());\n    }\n\n    function _proxyAdmin() internal view virtual returns (address) {\n        return _admin;\n    }\n\n    function _fallback() internal virtual override {\n        if (msg.sender == _proxyAdmin()) {\n            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                revert ProxyDeniedAdminAccess();\n            } else {\n                _dispatchUpgradeToAndCall();\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    function _dispatchUpgradeToAndCall() private {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.22;\n\nimport {ITransparentUpgradeableProxy} from \"./TransparentUpgradeableProxy.sol\";\nimport {Ownable} from \"../../access/Ownable.sol\";\n\ncontract ProxyAdmin is Ownable {\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n    constructor(address initialOwner) Ownable(initialOwner) {}\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.22;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\ncontract ERC1967Proxy is Proxy {\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.21;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\nlibrary ERC1967Utils {\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\nabstract contract Proxy {\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n    function _implementation() internal view virtual returns (address);\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1967.sol)\n\npragma solidity >=0.4.11;\n\ninterface IERC1967 {\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity >=0.4.16;\n\ninterface IBeacon {\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\nlibrary Address {\n    error AddressEmptyCode(address target);\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) { _revert(returndata); }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata) internal view returns (bytes memory) {\n        if (!success) { _revert(returndata); } else {\n            if (returndata.length == 0 && target.code.length == 0) { revert AddressEmptyCode(target); }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) { _revert(returndata); } else { return returndata; }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly (\"memory-safe\") { revert(add(returndata, 0x20), mload(returndata)) }\n        } else { revert Errors.FailedCall(); }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.20;\n\nlibrary StorageSlot {\n    struct AddressSlot { address value; }\n    struct BooleanSlot { bool value; }\n    struct Bytes32Slot { bytes32 value; }\n    struct Uint256Slot { uint256 value; }\n    struct Int256Slot { int256 value; }\n    struct StringSlot { string value; }\n    struct BytesSlot { bytes value; }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) { assembly (\"memory-safe\") { r.slot := slot } }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) { assembly (\"memory-safe\") { r.slot := slot } }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) { assembly (\"memory-safe\") { r.slot := slot } }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) { assembly (\"memory-safe\") { r.slot := slot } }\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) { assembly (\"memory-safe\") { r.slot := slot } }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) { assembly (\"memory-safe\") { r.slot := slot } }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) { assembly (\"memory-safe\") { r.slot := store.slot } }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) { assembly (\"memory-safe\") { r.slot := slot } }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) { assembly (\"memory-safe\") { r.slot := store.slot } }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) { return msg.sender; }\n    function _msgData() internal view virtual returns (bytes calldata) { return msg.data; }\n    function _contextSuffixLength() internal view virtual returns (uint256) { return 0; }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\nabstract contract Ownable is Context {\n    address private _owner;\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) { revert OwnableInvalidOwner(address(0)); }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() { _checkOwner(); _; }\n    function owner() public view virtual returns (address) { return _owner; }\n    function _checkOwner() internal view virtual { if (owner() != _msgSender()) { revert OwnableUnauthorizedAccount(_msgSender()); } }\n    function renounceOwnership() public virtual onlyOwner { _transferOwnership(address(0)); }\n    function transferOwnership(address newOwner) public virtual onlyOwner { if (newOwner == address(0)) { revert OwnableInvalidOwner(address(0)); } _transferOwnership(newOwner); }\n    function _transferOwnership(address newOwner) internal virtual { address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner); }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\nlibrary Errors {\n    error InsufficientBalance(uint256 balance, uint256 needed);\n    error FailedCall();\n    error FailedDeployment();\n    error MissingPrecompile(address);\n}\n"
    }
  }
}
