{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {IERC1967} from \"@openzeppelin/contracts/interfaces/IERC1967.sol\";\nimport {Proxy} from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ninterface ITransparentUpgradeableProxy { }\n\ncontract TransparentUpgradeableProxy is Proxy, IERC1967 {\n    constructor(address _logic, address admin_, bytes memory _data) payable {\n        ERC1967Utils.changeAdmin(admin_);\n        ERC1967Utils.upgradeToAndCall(_logic, _data);\n    }\n\n    function _implementation() internal view override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n\n// Minimal ProxyAdmin compatible with OZ v5 where admin ops use ERC1967Utils.\ncontract ProxyAdmin is Ownable {\n    // Read current implementation\n    function getProxyImplementation(address /*proxy*/) public view returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n\n    // Read current admin\n    function getProxyAdmin(address /*proxy*/) public view returns (address) {\n        return ERC1967Utils.getAdmin();\n    }\n\n    // Note: In OZ v5 TransparentUpgradeableProxy, changeAdmin/upgrade are not callable via the proxy type here.\n    // Admin operations are performed via ERC1967Utils from the proxy context.\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nimport {Proxy} from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n\ncontract ERC1967Proxy is Proxy {\n    constructor(address _logic, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(_logic, _data);\n    }\n    function _implementation() internal view override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {StorageSlot} from \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport {Errors} from \"@openzeppelin/contracts/utils/Errors.sol\";\n\nlibrary ERC1967Utils {\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 private constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function changeAdmin(address newAdmin) internal {\n        if (newAdmin == address(0)) revert Errors.InvalidAddress();\n        address previousAdmin = getAdmin();\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n        emit AdminChanged(previousAdmin, newAdmin);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        Address.functionDelegateCall(newImplementation, data);\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nabstract contract Proxy {\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    function _implementation() internal view virtual returns (address);\n\n    fallback() external payable virtual {\n        _delegate(_implementation());\n    }\n\n    receive() external payable virtual {\n        _delegate(_implementation());\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\ninterface IERC1967 { }\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\ninterface IBeacon {\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nlibrary Address {\n    function functionDelegateCall(address target, bytes memory data) internal {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        if (!success) {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nlibrary StorageSlot {\n    struct AddressSlot { address value; }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly { r.slot := slot }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() { _transferOwnership(_msgSender()); }\n    modifier onlyOwner() { require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); _; }\n    function owner() public view returns (address) { return _owner; }\n    function _transferOwnership(address newOwner) internal { address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner); }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) { return msg.sender; }\n    function _msgData() internal view virtual returns (bytes calldata) { return msg.data; }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nlibrary Errors {\n    error InvalidAddress();\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "ipfs"
    }
  }
}
